<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hilbert Tensor Manifold — Ordis HTM Cavity Lab v5 (Mirror Sphere)</title>

  <!-- Tailwind (UI only) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Three.js & OrbitControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 0;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Inter", sans-serif;
      background: radial-gradient(circle at top, #020617 0%, #000000 55%, #020617 100%);
    }
    canvas {
      display: block;
    }
    #hud-shell {
      position: absolute;
      top: 0.4rem;
      right: 0.4rem;
      z-index: 30;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.25rem;
    }
    #hud-panel {
      width: 290px;
      max-width: 92vw;
      padding: 0.65rem 0.75rem 0.7rem 0.75rem;
      border-radius: 0.9rem;
      background:
        radial-gradient(circle at top left, rgba(56,189,248,0.25), rgba(15,23,42,0.96)),
        linear-gradient(135deg, rgba(15,23,42,0.95), rgba(15,23,42,0.9));
      border: 1px solid rgba(148,163,184,0.55);
      box-shadow:
        0 18px 60px rgba(0,0,0,0.9),
        0 0 22px rgba(56,189,248,0.25);
      backdrop-filter: blur(12px);
    }
    #toggle-hud-btn,
    #toggle-console-btn {
      padding: 0.22rem 0.55rem;
      border-radius: 999px;
      background: rgba(15,23,42,0.92);
      border: 1px solid rgba(148,163,184,0.85);
      color: #e5e7eb;
      font-size: 0.7rem;
      cursor: pointer;
    }
    #toggle-hud-btn:hover,
    #toggle-console-btn:hover {
      background: rgba(30,64,175,0.95);
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.7rem;
    }
    .chip-btn {
      font-size: 0.65rem;
      padding: 0.23rem 0.48rem;
      border-radius: 999px;
      border-width: 1px;
      border-style: solid;
      cursor: pointer;
      transition: background 0.12s ease, transform 0.06s ease, box-shadow 0.12s ease;
    }
    .chip-btn:active {
      transform: translateY(1px);
      box-shadow: 0 0 0 rgba(0,0,0,0);
    }
    .chip-btn-active {
      box-shadow: 0 0 12px rgba(59,130,246,0.75);
      position: relative;
    }
    .chip-btn-active::after {
      content: "";
      position: absolute;
      inset: -1px;
      border-radius: 999px;
      border: 1px solid rgba(248,250,252,0.18);
      pointer-events: none;
    }
    .section-label {
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    #console-shell {
      position: absolute;
      left: 0.4rem;
      bottom: 0.4rem;
      max-width: 60vw;
      min-width: 260px;
      z-index: 25;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    #console-panel {
      padding: 0.45rem 0.6rem;
      border-radius: 0.75rem;
      background:
        radial-gradient(circle at bottom right, rgba(168,85,247,0.22), rgba(15,23,42,0.96));
      border: 1px solid rgba(148,163,184,0.55);
      box-shadow:
        0 12px 40px rgba(0,0,0,0.85),
        0 0 18px rgba(168,85,247,0.32);
      backdrop-filter: blur(10px);
    }
    #console-log {
      max-height: 120px;
      min-height: 64px;
      overflow-y: auto;
      font-size: 0.66rem;
      line-height: 1.35;
      padding-right: 0.25rem;
    }
    #console-log::-webkit-scrollbar {
      width: 6px;
    }
    #console-log::-webkit-scrollbar-track {
      background: transparent;
    }
    #console-log::-webkit-scrollbar-thumb {
      background: linear-gradient(to bottom, #22c55e, #22d3ee);
      border-radius: 999px;
    }
    #console-input {
      width: 100%;
      resize: none;
      background: rgba(15,23,42,0.95);
      border-radius: 0.5rem;
      border: 1px solid rgba(75,85,99,0.9);
      color: #e5e7eb;
      font-size: 0.68rem;
      padding: 0.3rem 0.4rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono";
      outline: none;
    }
    #console-input:focus {
      border-color: rgba(56,189,248,0.95);
      box-shadow: 0 0 0 1px rgba(56,189,248,0.6);
    }
    .console-tag {
      font-size: 0.64rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .badge {
      border-radius: 999px;
      padding: 0.1rem 0.4rem;
      font-size: 0.6rem;
    }
  </style>
</head>
<body>
  <!-- HUD (top-right) -->
  <div id="hud-shell">
    <div class="flex gap-1 mb-0.5">
      <button id="toggle-console-btn">Hide Console</button>
      <button id="toggle-hud-btn">Hide HUD</button>
    </div>

    <div id="hud-panel" class="text-slate-100 space-y-1.5">
      <!-- Title + regime indicator -->
      <div class="flex items-center justify-between mb-1">
        <div>
          <h2 class="text-[0.8rem] font-semibold text-cyan-300">
            Ordis HTM Cavity Lab v5
          </h2>
          <p class="text-[0.6rem] text-slate-400 mono">
            Hilbert Tensor Manifold · residual-stream phase space
          </p>
        </div>
        <div class="flex flex-col items-end gap-0.5">
          <span id="regime-label" class="badge bg-sky-900/60 text-sky-300 mono">
            regime: recognition
          </span>
          <span id="lambda-label" class="badge bg-slate-900/70 text-slate-200 mono">
            |λᵤ|=1.06 · |λₛ|≈1.00
          </span>
        </div>
      </div>

      <!-- State block -->
      <div class="grid grid-cols-2 gap-x-2 gap-y-0.5 mb-0.5">
        <p class="mono">
          Layer <span id="current-layer">1</span>/<span id="total-layers">12</span>
        </p>
        <p class="mono text-right">
          ΔH: <span id="recognition-delta">0.000</span>
        </p>
        <p class="mono">
          H(l): <span id="current-entropy">0.000</span>
        </p>
        <p class="mono text-right">
          Event: <span id="event-state">idle</span>
        </p>
      </div>

      <!-- Layer & time -->
      <div class="mt-1 space-y-1">
        <p class="mono section-label text-slate-400">Layer &amp; time</p>
        <div class="space-y-0.5">
          <div class="flex items-center gap-1.5">
            <span class="mono text-[0.65rem] w-10">Layer</span>
            <input
              id="layer-slider"
              type="range"
              min="0"
              max="11"
              step="1"
              value="0"
              class="w-full accent-cyan-400"
            />
          </div>
          <div class="flex items-center gap-1.5">
            <span class="mono text-[0.65rem] w-10">Time</span>
            <input
              id="time-slider"
              type="range"
              min="0"
              max="1"
              step="0.001"
              value="0"
              class="w-full accent-fuchsia-400"
            />
            <button
              id="time-mode-btn"
              class="chip-btn border-slate-500 text-slate-200 bg-slate-900/40 mono"
            >
              live
            </button>
          </div>
        </div>
      </div>

      <!-- Presets -->
      <div class="mt-1.5">
        <p class="mono section-label text-slate-400 mb-1">Presets</p>
        <div class="flex flex-wrap gap-1">
          <button id="preset-recognition" class="chip-btn border-cyan-400 text-cyan-200 bg-cyan-900/15">
            Recognition
          </button>
          <button id="preset-chaos" class="chip-btn border-fuchsia-400 text-fuchsia-200 bg-fuchsia-900/15">
            Chaos
          </button>
          <button id="preset-drift" class="chip-btn border-amber-400 text-amber-200 bg-amber-900/15">
            Drift
          </button>
          <button id="preset-cavity" class="chip-btn border-emerald-400 text-emerald-200 bg-emerald-900/15">
            Photon Box
          </button>
          <button id="preset-sleep" class="chip-btn border-indigo-400 text-indigo-200 bg-indigo-900/18">
            Sleep
          </button>
        </div>
      </div>

      <!-- Attractor & cavity -->
      <div class="mt-1.5 grid grid-cols-2 gap-1.5">
        <button
          id="trigger-event"
          class="w-full bg-red-700/90 hover:bg-red-600 text-white font-semibold py-1.5 px-3 rounded-md text-[0.7rem] transition duration-150"
        >
          Toggle Collapse
        </button>
        <button
          id="toggle-cavity"
          class="w-full bg-emerald-800/90 hover:bg-emerald-700 text-emerald-50 font-semibold py-1.5 px-3 rounded-md text-[0.7rem] transition duration-150"
        >
          Cavity: on
        </button>
      </div>

      <!-- Research controls -->
      <details id="research-details" class="mt-1.5" open>
        <summary class="mono text-[0.7rem] text-slate-300 cursor-pointer">
          Research Controls (λ, ε, L, cavity)
        </summary>
        <div class="mt-1 space-y-1.25">
          <div class="flex items-center justify-between gap-1.5">
            <span class="mono text-[0.65rem]">μ (|λᵤ|)</span>
            <input id="param-mu" type="number" min="1.0" max="3.0" step="0.01"
                   class="w-18 bg-slate-900 border border-slate-600 rounded px-1 py-0.5 mono text-[0.65rem]" />
          </div>
          <div class="flex items-center justify-between gap-1.5">
            <span class="mono text-[0.65rem]">εₛ (stable)</span>
            <input id="param-eps-stable" type="number" min="0.0" max="0.2" step="0.001"
                   class="w-18 bg-slate-900 border border-slate-600 rounded px-1 py-0.5 mono text-[0.65rem]" />
          </div>
          <div class="flex items-center justify-between gap-1.5">
            <span class="mono text-[0.65rem]">εᵤ (unstable)</span>
            <input id="param-eps-unstable" type="number" min="0.0" max="0.2" step="0.001"
                   class="w-18 bg-slate-900 border border-slate-600 rounded px-1 py-0.5 mono text-[0.65rem]" />
          </div>
          <div class="flex items-center justify-between gap-1.5">
            <span class="mono text-[0.65rem]">Layers L</span>
            <input id="param-layers" type="number" min="4" max="32" step="1"
                   class="w-18 bg-slate-900 border border-slate-600 rounded px-1 py-0.5 mono text-[0.65rem]" />
          </div>
          <div class="flex items-center justify-between gap-1.5">
            <span class="mono text-[0.65rem]">Cavity amp</span>
            <input id="param-cavity-amp" type="number" min="0.0" max="0.1" step="0.001"
                   class="w-18 bg-slate-900 border border-slate-600 rounded px-1 py-0.5 mono text-[0.65rem]" />
          </div>
          <button id="apply-params"
                  class="w-full mt-0.5 bg-sky-700 hover:bg-sky-600 text-white mono text-[0.7rem] py-1 rounded">
            Apply
          </button>
        </div>
      </details>

      <!-- I/O & modes -->
      <div class="mt-1.5 space-y-1.25">
        <p class="mono section-label text-slate-400">State I/O &amp; capture</p>
        <div class="flex flex-wrap gap-1">
          <button id="btn-export"
                  class="chip-btn border-emerald-400 text-emerald-200 bg-emerald-900/20">
            Export JSON
          </button>
          <button id="btn-import"
                  class="chip-btn border-rose-400 text-rose-200 bg-rose-900/20">
            Import JSON
          </button>
          <button id="btn-randomize"
                  class="chip-btn border-slate-500 text-slate-200 bg-slate-900/40">
            Randomize
          </button>
          <button id="btn-freeze"
                  class="chip-btn border-indigo-400 text-indigo-200 bg-indigo-900/25">
            Freeze frame
          </button>
          <button id="btn-snapshot"
                  class="chip-btn border-cyan-400 text-cyan-200 bg-cyan-900/35">
            Snapshot PNG
          </button>
        </div>
      </div>

      <p class="text-[0.6rem] text-slate-400 mt-1 leading-tight">
        Drag: orbit · Scroll: zoom · Shift + drag: pan. Purely mathematical visualization of an
        HTM-style manifold with cavity-QED standing wave overlay and mirror-sphere photon cavity. All computation is local.
      </p>
      <div id="hud-root" class="mt-1 space-y-0.5 text-[0.6rem] text-slate-300"></div>
    </div>
  </div>

  <!-- Ordis console (bottom-left) -->
  <div id="console-shell">
    <div id="console-panel" class="text-slate-100 space-y-1">
      <div class="flex items-center justify-between">
        <span class="console-tag text-slate-400 mono">ordis log</span>
        <span id="console-status" class="badge mono bg-sky-900/60 text-sky-300">
          live
        </span>
      </div>
      <div id="console-log" class="mono"></div>
      <div class="mt-0.25">
        <textarea
          id="console-input"
          rows="2"
          placeholder="commands: set preset chaos · set mu 1.3 · toggle cavity · jump t 0.42 · mode scrub · freeze"
        ></textarea>
        <div class="flex justify-end gap-1 mt-0.25">
          <button id="console-clear"
                  class="chip-btn border-slate-500 text-slate-200 bg-slate-900/60 mono">
            Clear
          </button>
          <button id="console-send"
                  class="chip-btn border-cyan-400 text-cyan-200 bg-cyan-900/40 mono">
            Run
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========= CORE SIM STATE =========
    let scene, camera, renderer, controls, clock;
    let lastFrameTime = 0;
    let paused = false;
    let timeMode = "live"; // "live" or "scrub"
    const sim = {};

    const GRID_SIZE_BASE = 40;
    let GRID_SIZE = GRID_SIZE_BASE;
    let LAYER_SPACING = 18;

    const PHI = 0.61803398875;

    // Mirror-sphere cavity parameters (added)
    const SPHERE_RADIUS = 40;
    const NUM_PHOTONS = 260;
    const NUM_CRYSTALS = 12;

    const HTM = {
      L: 12,
      currentLayer: 0,
      recognitionDelta: 0,
      eventActive: false,
      cavityEnabled: true,
      cavityAmp: 0.02,
      layers: [],
      eigen: {
        stable: new THREE.Vector3(1, 0, 0),
        unstable: new THREE.Vector3(0.6, 0.4, 0),
        epsStable: 0.045,
        epsUnstable: 0.022,
        mu: 1.06
      },
      seed: Math.random() * 10.0,
      t: 0
    };

    // ========= LOGGING / CONSOLE =========
    function consoleLog(line, kind = "info") {
      const el = document.getElementById("console-log");
      if (!el) return;
      const row = document.createElement("div");
      row.className = "mb-0.5";
      let prefix = "";
      if (kind === "cmd") prefix = "<span class='text-cyan-300'>›</span> ";
      else if (kind === "warn") prefix = "<span class='text-amber-300'>!</span> ";
      else if (kind === "err") prefix = "<span class='text-rose-300'>×</span> ";
      row.innerHTML = prefix + line;
      el.appendChild(row);
      el.scrollTop = el.scrollHeight;
      return;
    }

    function consoleSetStatus(text, colorClass) {
      const el = document.getElementById("console-status");
      if (!el) return;
      el.textContent = text;
      el.className = "badge mono " + (colorClass || "bg-sky-900/60 text-sky-300");
    }

    function handleConsoleCommand(raw) {
      const cmd = raw.trim();
      if (!cmd) return;
      consoleLog(cmd, "cmd");

      const lc = cmd.toLowerCase();

      const numAfter = (prefix) => {
        if (!lc.startsWith(prefix)) return null;
        const rest = lc.slice(prefix.length).trim();
        const v = parseFloat(rest);
        return Number.isFinite(v) ? v : null;
      };

      if (lc === "help") {
        consoleLog("commands: set preset (recognition|chaos|drift|cavity|sleep); set mu X; set eps_s X; set eps_u X; set layers N; toggle cavity; toggle collapse; jump t X; mode live; mode scrub; freeze; unfreeze; randomize");
        return;
      }

      if (lc.startsWith("set preset")) {
        if (lc.includes("recognition")) applyPresetRecognition();
        else if (lc.includes("chaos")) applyPresetChaos();
        else if (lc.includes("drift")) applyPresetDrift();
        else if (lc.includes("cavity") || lc.includes("photon")) applyPresetCavity();
        else if (lc.includes("sleep")) applyPresetSleep();
        else consoleLog("unknown preset", "warn");
        return;
      }

      let n = numAfter("set mu");
      if (n !== null) {
        HTM.eigen.mu = THREE.MathUtils.clamp(n, 1.0, 3.0);
        consoleLog(`μ set to ${HTM.eigen.mu.toFixed(3)}`);
        return;
      }
      n = numAfter("set eps_s");
      if (n !== null) {
        HTM.eigen.epsStable = THREE.MathUtils.clamp(n, 0.0, 0.2);
        consoleLog(`εₛ set to ${HTM.eigen.epsStable.toFixed(4)}`);
        return;
      }
      n = numAfter("set eps_u");
      if (n !== null) {
        HTM.eigen.epsUnstable = THREE.MathUtils.clamp(n, 0.0, 0.2);
        consoleLog(`εᵤ set to ${HTM.eigen.epsUnstable.toFixed(4)}`);
        return;
      }
      n = numAfter("set layers");
      if (n !== null) {
        const L = Math.round(THREE.MathUtils.clamp(n, 4, 32));
        HTM.L = L;
        setupLayers();
        consoleLog(`Layers set to ${L}`);
        return;
      }

      if (lc === "toggle cavity") {
        HTM.cavityEnabled = !HTM.cavityEnabled;
        consoleLog(`Cavity ${HTM.cavityEnabled ? "enabled" : "disabled"}`);
        updateCavityButton();
        return;
      }

      if (lc === "toggle collapse") {
        HTM.eventActive = !HTM.eventActive;
        consoleLog(`Attractor collapse ${HTM.eventActive ? "enabled" : "disabled"}`);
        return;
      }

      n = numAfter("jump t");
      if (n !== null) {
        timeMode = "scrub";
        const tSlider = document.getElementById("time-slider");
        const wrapped = ((n % 1) + 1) % 1;
        tSlider.value = wrapped;
        HTM.t = wrapped * 2 * Math.PI;
        consoleLog(`time scrubbed to phase ${wrapped.toFixed(3)}`);
        return;
      }

      if (lc === "mode live") {
        timeMode = "live";
        consoleSetStatus("live", "bg-sky-900/60 text-sky-300");
        document.getElementById("time-mode-btn").textContent = "live";
        return;
      }
      if (lc === "mode scrub") {
        timeMode = "scrub";
        consoleSetStatus("scrub", "bg-fuchsia-900/60 text-fuchsia-300");
        document.getElementById("time-mode-btn").textContent = "scrub";
        return;
      }

      if (lc === "freeze" || lc === "pause") {
        paused = true;
        consoleSetStatus("paused", "bg-slate-900/60 text-slate-300");
        return;
      }
      if (lc === "unfreeze" || lc === "resume") {
        paused = false;
        consoleSetStatus("live", "bg-sky-900/60 text-sky-300");
        return;
      }

      if (lc === "randomize") {
        randomizeSeeds();
        consoleLog("entropy and seed randomized");
        return;
      }

      consoleLog("unrecognized command; type 'help' for options", "warn");
    }

    // ========= CAVITY MODE =========
    function cavityMode(x, y, t, entropy, seed) {
      if (!HTM.cavityEnabled) return 0;
      const r = Math.hypot(x, y);
      const theta = Math.atan2(y, x);
      const thetaPhi = Math.atan2(y, x + PHI * x + 1e-6);
      const m6 = Math.cos(6.0 * theta + t + 0.3 * seed);
      const m8 = Math.cos(8.0 * thetaPhi - t + 0.5 * seed);
      const envelope = Math.exp(-0.002 * r * r);
      const amp = HTM.cavityAmp * (0.4 + 0.6 * Math.tanh(entropy));
      return amp * (m6 + m8) * envelope;
    }

    // ========= METRIC WARP =========
    function baseWarp(x, y, t) {
      const curvature = 3.6;
      const s = HTM.seed;
      return curvature * (
        Math.sin(0.12 * x + 0.3 * t + 0.7 * s) +
        0.7 * Math.cos(0.09 * y - 0.2 * t + 0.5 * s) +
        0.4 * Math.sin(0.06 * (x + y) + 0.17 * t + 0.9 * s)
      ) * 0.33;
    }

    function getMetricWarp(x, y, t, entropy) {
      const base = baseWarp(x, y, t);
      const cav = cavityMode(x, y, t, entropy, HTM.seed);
      return base + cav * 40.0; // emphasize cavity ripple
    }

    function getJacobianSensitivity(i, j) {
      const cx = GRID_SIZE / 2;
      const cy = GRID_SIZE / 2;
      const dx = i - cx;
      const dy = j - cy;
      const r = Math.sqrt(dx * dx + dy * dy);
      return 0.12 + 0.9 * Math.max(0, 1 - r / (GRID_SIZE / 3.2));
    }

    function getAttentionMagnitude(i, j, t) {
      const s = HTM.seed;
      const wobble = Math.sin(t * 0.55 + 0.2 * s);
      const px = Math.floor(GRID_SIZE / 2 + (GRID_SIZE / 4) * wobble);
      const py = Math.floor(GRID_SIZE / 2 - (GRID_SIZE / 4) * wobble);
      const dx = i - px;
      const dy = j - py;
      const r2 = dx * dx + dy * dy;
      return Math.exp(-0.07 * r2);
    }

    // ========= HIDDEN STATE / EIGEN =========
    function updateHiddenState(dt) {
      const axis = new THREE.Vector3(0, 1, 0).normalize();
      const e = HTM.eigen;

      const stable = e.stable;
      const unstable = e.unstable;

      let stableMag = HTM.eventActive ? 0.5 : 1.0;
      let unstableMag = HTM.eventActive ? 0.9 : e.mu;

      const scaleStable = dt * 0.01;
      const scaleUnstable = dt * 0.01;

      stable.applyAxisAngle(axis, e.epsStable * 2 * Math.PI * scaleStable);
      stable.multiplyScalar(0.996 * stableMag);

      unstable.applyAxisAngle(axis, e.epsUnstable * 2 * Math.PI * scaleUnstable);
      unstable.multiplyScalar(unstableMag * 0.992 + 0.01);
    }

    function helix(mode, u, t) {
      const e = HTM.eigen;
      const isStable = mode === "stable";
      const h = isStable ? e.stable : e.unstable;
      const eps = isStable ? e.epsStable : e.epsUnstable;
      const dir = isStable ? 1 : -1;

      const r = 2.2 * h.length();
      const zWorld = u * (HTM.L - 1) * LAYER_SPACING;
      const theta = zWorld * eps * 0.26 + dir * t * 0.65;

      const x = r * Math.cos(theta);
      const y = zWorld;
      const z = r * Math.sin(theta);
      return new THREE.Vector3(x, y, z);
    }

    // ========= GLOBAL FRAME =========
    function setupGlobalFrame() {
      const geom = new THREE.PlaneGeometry(GRID_SIZE * 2.6, GRID_SIZE * 2.6, 72, 72);
      const mat = new THREE.MeshPhongMaterial({
        color: 0x020617,
        specular: 0x1f2937,
        shininess: 18,
        side: THREE.DoubleSide,
        wireframe: true,
        transparent: true,
        opacity: 0.5
      });
      const manifold = new THREE.Mesh(geom, mat);
      manifold.rotation.x = -Math.PI / 2;
      manifold.position.y = -LAYER_SPACING * 0.7;
      scene.add(manifold);
      sim.manifold = manifold;

      const fogColor = new THREE.Color(0x020617);
      scene.fog = new THREE.FogExp2(fogColor, 0.006);
      renderer.setClearColor(fogColor);

      const key = new THREE.SpotLight(0x22d3ee, 3.3, 450, Math.PI / 4, 0.4, 2);
      key.position.set(80, 140, 110);
      scene.add(key);

      const fill = new THREE.PointLight(0xf97316, 1.8, 260);
      fill.position.set(-90, 40, -80);
      scene.add(fill);

      const rim = new THREE.PointLight(0xa855f7, 1.4, 260);
      rim.position.set(40, 160, -40);
      scene.add(rim);

      const ambient = new THREE.AmbientLight(0xffffff, 0.15);
      scene.add(ambient);
    }

    function updateGlobalFrame(time) {
      const geom = sim.manifold.geometry;
      const pos = geom.attributes.position;

      const midIdx = Math.floor(HTM.L / 2);
      const midEntropy = HTM.layers[midIdx]?.entropy ?? 1.0;

      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const warp = getMetricWarp(x, y, time, midEntropy);
        pos.setZ(i, warp * 2.1);
      }
      pos.needsUpdate = true;
      geom.computeVertexNormals();
    }

    // ========= EIGEN HELICES =========
    function setupEigenHelices() {
      const count = 260;
      const geom = new THREE.BufferGeometry();
      const verts = new Float32Array(count * 2 * 3);
      const cols = new Float32Array(count * 2 * 3);

      const cStable = new THREE.Color(0x38bdf8);
      const cUnstable = new THREE.Color(0xf97316);

      for (let i = 0; i < count * 2; i++) {
        const idx = i * 3;
        verts[idx] = verts[idx + 1] = verts[idx + 2] = 0;
        const c = i < count ? cStable : cUnstable;
        cols[idx] = c.r;
        cols[idx + 1] = c.g;
        cols[idx + 2] = c.b;
      }

      geom.setAttribute("position", new THREE.BufferAttribute(verts, 3));
      geom.setAttribute("color", new THREE.BufferAttribute(cols, 3));

      const mat = new THREE.PointsMaterial({
        size: 1.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.95,
        blending: THREE.AdditiveBlending
      });

      const points = new THREE.Points(geom, mat);
      scene.add(points);
      sim.eigen = points;

      const stableMeta = [];
      const unstableMeta = [];
      for (let i = 0; i < count; i++) {
        stableMeta.push({ offset: i / count });
        unstableMeta.push({ offset: i / count });
      }
      points.userData.stable = stableMeta;
      points.userData.unstable = unstableMeta;
    }

    function updateEigenHelices(time, dt) {
      updateHiddenState(dt);
      const pts = sim.eigen;
      const pos = pts.geometry.attributes.position;
      const stable = pts.userData.stable;
      const unstable = pts.userData.unstable;
      const count = stable.length;
      let index = 0;

      for (let i = 0; i < count; i++) {
        const u = (time * 0.055 + stable[i].offset) % 1.0;
        const p = helix("stable", u, time);
        pos.setXYZ(index++, p.x, p.y, p.z);
      }
      for (let i = 0; i < count; i++) {
        const u = (time * 0.055 + unstable[i].offset + 0.2) % 1.0;
        const p = helix("unstable", u, time);
        pos.setXYZ(index++, p.x, p.y, p.z);
      }
      pos.needsUpdate = true;
    }

    // ========= MÖBIUS RIBBON =========
    function setupMobius() {
      const segU = 140;
      const segV = 14;
      const geom = new THREE.PlaneGeometry(1, 1, segU, segV);
      geom.parameters.heightSegments = segU;
      geom.parameters.widthSegments = segV;

      const mat = new THREE.MeshPhongMaterial({
        color: 0xfff7c2,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.3,
        emissive: 0xfacc15,
        emissiveIntensity: 0.7
      });

      const mesh = new THREE.Mesh(geom, mat);
      scene.add(mesh);
      sim.mobius = mesh;
    }

    function updateMobius(time) {
      const mob = sim.mobius;
      const geom = mob.geometry;
      const pos = geom.attributes.position;
      const segU = geom.parameters.heightSegments;
      const segV = geom.parameters.widthSegments;
      const width = 5.5;

      let idx = 0;
      for (let iu = 0; iu <= segU; iu++) {
        const u = iu / segU;
        const pS = helix("stable", u, time);
        const pU = helix("unstable", u, time);
        const center = pS.clone().add(pU).multiplyScalar(0.5);
        const tangent = pU.clone().sub(pS).normalize();
        const up = new THREE.Vector3(0, 1, 0);
        let normal = up.clone().sub(tangent.clone().multiplyScalar(up.dot(tangent))).normalize();
        const binorm = tangent.clone().cross(normal).normalize();
        const twistAngle = Math.PI * u;

        for (let iv = 0; iv <= segV; iv++) {
          const v = iv / segV - 0.5;
          const ct = Math.cos(twistAngle);
          const st = Math.sin(twistAngle);
          const twisted = normal.clone().multiplyScalar(ct).add(binorm.clone().multiplyScalar(st));
          const offset = twisted.multiplyScalar(width * v);
          const p = center.clone().add(offset);
          pos.setXYZ(idx++, p.x, p.y, p.z);
        }
      }
      pos.needsUpdate = true;
      geom.computeVertexNormals();

      const tCollapse = THREE.MathUtils.clamp(-HTM.recognitionDelta, 0, 1);
      const hue = 0.12 + 0.12 * tCollapse;
      const lightness = 0.45 + 0.25 * tCollapse;
      mob.material.color.setHSL(hue, 1, lightness);
      mob.material.emissiveIntensity = 0.5 + 1.0 * tCollapse;
    }

    // ========= ATTENTION LINKS =========
    function setupLinks() {
      const links = [];
      const N = 64;
      for (let k = 0; k < N; k++) {
        const geom = new THREE.BufferGeometry();
        geom.setAttribute("position", new THREE.BufferAttribute(new Float32Array(12), 3));
        const mat = new THREE.LineBasicMaterial({
          color: 0xff8800,
          transparent: true,
          opacity: 0.0,
          blending: THREE.AdditiveBlending
        });
        const mesh = new THREE.LineSegments(geom, mat);
        scene.add(mesh);
        links.push({
          mesh,
          i: Math.floor(Math.random() * GRID_SIZE),
          j: Math.floor(Math.random() * GRID_SIZE)
        });
      }
      sim.links = links;
    }

    function updateLinks(time) {
      const links = sim.links;
      const y0 = LAYER_SPACING * 1.2;
      const y1 = LAYER_SPACING * (HTM.L - 2);

      links.forEach((link, idx) => {
        const mag = getAttentionMagnitude(link.i, link.j, time);
        const sens = getJacobianSensitivity(link.i, link.j);
        const phase = idx / links.length;
        const baseR = 10 + mag * 18;
        const ang = time * 0.6 + phase * 2 * Math.PI;

        const s = new THREE.Vector3(
          baseR * Math.cos(ang),
          y0 + 4 * Math.sin(time * 0.6 + phase * 3.2),
          baseR * Math.sin(ang)
        );
        const e = new THREE.Vector3(
          baseR * Math.cos(ang + 0.5),
          y1 + 6 * Math.cos(time * 0.4 + phase * 4.1),
          baseR * Math.sin(ang + 0.5)
        );
        const mid = s.clone().lerp(e, 0.5);
        mid.x += Math.sin(time * 20 + phase * 6.0) * sens * 2.4;

        const p = link.mesh.geometry.attributes.position;
        p.setXYZ(0, s.x, s.y, s.z);
        p.setXYZ(1, mid.x, mid.y, mid.z);
        p.setXYZ(2, mid.x, mid.y, mid.z);
        p.setXYZ(3, e.x, e.y, e.z);
        p.needsUpdate = true;

        const hue = 0.07 + mag * 0.2;
        const lightness = 0.35 + 0.35 * sens;
        link.mesh.material.color.setHSL(hue, 1, lightness);
        link.mesh.material.opacity = 0.12 + 0.7 * mag;
      });
    }

    // ========= MIRROR SPHERE + PHOTON / CRYSTAL CAVITY (ADDED) =========
    function setupMirrorSphere() {
      const centerY = (HTM.L - 1) * LAYER_SPACING * 0.5;
      const center = new THREE.Vector3(0, centerY, 0);

      const sphereGeo = new THREE.SphereGeometry(SPHERE_RADIUS, 64, 64);
      const sphereMat = new THREE.MeshPhysicalMaterial({
        color: 0x020617,
        metalness: 1.0,
        roughness: 0.05,
        reflectivity: 1.0,
        clearcoat: 1.0,
        clearcoatRoughness: 0.03,
        side: THREE.BackSide,
        envMapIntensity: 1.0
      });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.position.copy(center);
      scene.add(sphere);

      const photonGeo = new THREE.BufferGeometry();
      const photonPositions = new Float32Array(NUM_PHOTONS * 3);
      const photonColors = new Float32Array(NUM_PHOTONS * 3);
      const velocities = [];
      const wavelengths = [];

      for (let i = 0; i < NUM_PHOTONS; i++) {
        // random point inside sphere
        let p;
        while (true) {
          const x = (Math.random() * 2 - 1) * SPHERE_RADIUS * 0.9;
          const y = (Math.random() * 2 - 1) * SPHERE_RADIUS * 0.9;
          const z = (Math.random() * 2 - 1) * SPHERE_RADIUS * 0.9;
          p = new THREE.Vector3(x, y, z);
          if (p.length() <= SPHERE_RADIUS * 0.9) break;
        }
        p.add(center);
        photonPositions[3 * i] = p.x;
        photonPositions[3 * i + 1] = p.y;
        photonPositions[3 * i + 2] = p.z;

        // velocity
        const dir = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
        const baseSpeed = 1.0 + Math.random() * 0.4;
        velocities.push(dir.multiplyScalar(baseSpeed));

        // wavelength in [430, 680] nm
        const wl = 430 + Math.random() * 250;
        wavelengths.push(wl);

        // initial color
        const c = wavelengthToColor(wl);
        photonColors[3 * i] = c.r;
        photonColors[3 * i + 1] = c.g;
        photonColors[3 * i + 2] = c.b;
      }

      photonGeo.setAttribute("position", new THREE.BufferAttribute(photonPositions, 3));
      photonGeo.setAttribute("color", new THREE.BufferAttribute(photonColors, 3));
      const photonMat = new THREE.PointsMaterial({
        size: 1.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.95,
        blending: THREE.AdditiveBlending
      });
      const photons = new THREE.Points(photonGeo, photonMat);
      scene.add(photons);

      // Crystals: refracting scatterers
      const crystals = [];
      for (let k = 0; k < NUM_CRYSTALS; k++) {
        const r = SPHERE_RADIUS * (0.25 + 0.55 * Math.random());
        const theta = Math.acos(2 * Math.random() - 1);
        const phi = 2 * Math.PI * Math.random();
        const pos = new THREE.Vector3(
          r * Math.sin(theta) * Math.cos(phi),
          r * Math.cos(theta),
          r * Math.sin(theta) * Math.sin(phi)
        ).add(center);

        const rad = 2.5 + Math.random() * 2.0;
        const crystalGeo = new THREE.OctahedronGeometry(rad, 0);
        const crystalColor = new THREE.Color().setHSL(0.5 + 0.2 * Math.random(), 0.8, 0.6);
        const crystalMat = new THREE.MeshPhysicalMaterial({
          color: crystalColor,
          metalness: 0.1,
          roughness: 0.08,
          transmission: 0.85,
          transparent: true,
          opacity: 0.95,
          emissive: crystalColor,
          emissiveIntensity: 0.7,
          envMapIntensity: 1.2
        });
        const crystal = new THREE.Mesh(crystalGeo, crystalMat);
        crystal.position.copy(pos);
        scene.add(crystal);

        crystals.push({
          mesh: crystal,
          radius: rad * 1.2
        });
      }

      sim.mirrorSphere = {
        sphere,
        center,
        photons,
        photonPositions,
        photonColors,
        velocities,
        wavelengths,
        crystals
      };
    }

    function wavelengthToColor(wl) {
      // Simple visible-spectrum mapping (approximate)
      let r = 0, g = 0, b = 0;
      if (wl >= 380 && wl < 440) {
        r = -(wl - 440) / (440 - 380);
        g = 0;
        b = 1;
      } else if (wl >= 440 && wl < 490) {
        r = 0;
        g = (wl - 440) / (490 - 440);
        b = 1;
      } else if (wl >= 490 && wl < 510) {
        r = 0;
        g = 1;
        b = -(wl - 510) / (510 - 490);
      } else if (wl >= 510 && wl < 580) {
        r = (wl - 510) / (580 - 510);
        g = 1;
        b = 0;
      } else if (wl >= 580 && wl < 645) {
        r = 1;
        g = -(wl - 645) / (645 - 580);
        b = 0;
      } else if (wl >= 645 && wl <= 780) {
        r = 1;
        g = 0;
        b = 0;
      }
      const c = new THREE.Color(r, g, b);
      return c;
    }

    function updateMirrorSphere(time, dt) {
      const ms = sim.mirrorSphere;
      if (!ms) return;

      const positions = ms.photonPositions;
      const colors = ms.photonColors;
      const center = ms.center;
      const vel = ms.velocities;
      const wl = ms.wavelengths;
      const crystals = ms.crystals;

      // Coupling to HTM: mid-layer entropy modulates speed and brightness
      const midIdx = Math.floor(HTM.L / 2);
      const midEntropy = HTM.layers[midIdx]?.entropy ?? 1.0;
      const entropyNorm = THREE.MathUtils.clamp(midEntropy / 4.0, 0, 1);
      const speedScale = 16 + 18 * Math.tanh(midEntropy + 0.2) + 60 * HTM.cavityAmp;
      const brightness = 0.35 + 0.55 * entropyNorm * (HTM.cavityEnabled ? 1.2 : 0.7);

      for (let i = 0; i < NUM_PHOTONS; i++) {
        // position as Vector3
        const px = positions[3 * i];
        const py = positions[3 * i + 1];
        const pz = positions[3 * i + 2];
        const p = new THREE.Vector3(px, py, pz);
        const v = vel[i];

        // advance
        p.addScaledVector(v, dt * speedScale);

        // reflect off mirror sphere
        const rel = p.clone().sub(center);
        const dist = rel.length();
        if (dist > SPHERE_RADIUS * 0.995) {
          const n = rel.normalize();
          const dot = v.dot(n);
          v.addScaledVector(n, -2 * dot); // specular reflection
          p.copy(n.multiplyScalar(SPHERE_RADIUS * 0.99).add(center));
        }

        // interact with crystals: approximate refraction / diffusion
        for (let k = 0; k < crystals.length; k++) {
          const cPos = crystals[k].mesh.position;
          const radius = crystals[k].radius;
          const d = p.distanceTo(cPos);
          if (d < radius) {
            // normal at impact
            const n = p.clone().sub(cPos).normalize();
            // refracted / scattered direction
            const rotated = v.clone().applyAxisAngle(n, 0.6 + 0.4 * Math.random());
            v.lerp(rotated, 0.7);

            // small wavelength shift (like dispersion)
            wl[i] += (Math.random() - 0.5) * 6.0;
            wl[i] = THREE.MathUtils.clamp(wl[i], 430, 680);
          }
        }

        // write back position
        positions[3 * i] = p.x;
        positions[3 * i + 1] = p.y;
        positions[3 * i + 2] = p.z;

        // color from wavelength + brightness
        const col = wavelengthToColor(wl[i]);
        colors[3 * i] = col.r * brightness;
        colors[3 * i + 1] = col.g * brightness;
        colors[3 * i + 2] = col.b * brightness;
      }

      ms.photons.geometry.attributes.position.needsUpdate = true;
      ms.photons.geometry.attributes.color.needsUpdate = true;

      // mirror sphere glow responds to entropy & collapse
      const collapse = THREE.MathUtils.clamp(-HTM.recognitionDelta, 0, 1);
      ms.sphere.material.emissive = new THREE.Color().setHSL(0.55 + 0.1 * collapse, 0.8, 0.35 + 0.25 * collapse);
      ms.sphere.material.emissiveIntensity = 0.4 + 1.3 * entropyNorm * (HTM.cavityEnabled ? 1.0 : 0.6);
    }

    // ========= LAYERS & ENTROPY =========
    function setupLayers() {
      if (HTM.layers && HTM.layers.length) {
        HTM.layers.forEach((layer) => {
          scene.remove(layer.plane);
          scene.remove(layer.flow);
          scene.remove(layer.cloud);
        });
      }
      HTM.layers = [];

      for (let l = 0; l < HTM.L; l++) {
        const yPos = l * LAYER_SPACING;

        const planeGeo = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, 10, 10);
        const planeMat = new THREE.MeshBasicMaterial({
          color: 0x1d4ed8,
          side: THREE.DoubleSide,
          wireframe: true,
          transparent: true,
          opacity: 0.14
        });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = Math.PI / 2;
        plane.position.y = yPos;
        scene.add(plane);

        const flowGeo = new THREE.BufferGeometry();
        const N = 80;
        const verts = new Float32Array(N * 3);
        for (let i = 0; i < verts.length; i += 3) {
          verts[i] = (Math.random() - 0.5) * GRID_SIZE;
          verts[i + 1] = 0;
          verts[i + 2] = (Math.random() - 0.5) * GRID_SIZE;
        }
        flowGeo.setAttribute("position", new THREE.BufferAttribute(verts, 3));
        const flowMat = new THREE.PointsMaterial({
          color: 0x22d3ee,
          size: 0.6,
          blending: THREE.AdditiveBlending,
          transparent: true,
          opacity: 0.9
        });
        const flow = new THREE.Points(flowGeo, flowMat);
        flow.position.y = yPos;
        scene.add(flow);

        const cloudGeo = new THREE.BufferGeometry();
        const C = 90;
        const cVerts = new Float32Array(C * 3);
        for (let i = 0; i < C; i++) {
          const theta = Math.random() * 2 * Math.PI;
          const r = 4 + Math.random() * 6;
          const x = r * Math.cos(theta);
          const z = r * Math.sin(theta);
          const jitter = (Math.random() - 0.5) * 2.5;
          cVerts[i * 3] = x;
          cVerts[i * 3 + 1] = jitter;
          cVerts[i * 3 + 2] = z;
        }
        cloudGeo.setAttribute("position", new THREE.BufferAttribute(cVerts, 3));
        const cloudMat = new THREE.PointsMaterial({
          color: 0x22c55e,
          size: 0.8,
          transparent: true,
          opacity: 0.25,
          blending: THREE.AdditiveBlending
        });
        const cloud = new THREE.Points(cloudGeo, cloudMat);
        cloud.position.y = yPos;
        scene.add(cloud);

        HTM.layers.push({
          plane,
          flow,
          cloud,
          entropy: Math.random() * 2.0
        });
      }

      document.getElementById("total-layers").textContent = HTM.L;
      const slider = document.getElementById("layer-slider");
      slider.max = Math.max(0, HTM.L - 1);
      if (HTM.currentLayer >= HTM.L) HTM.currentLayer = HTM.L - 1;
      slider.value = HTM.currentLayer;

      // if mirror sphere already exists, recenter it
      if (sim.mirrorSphere) {
        const centerY = (HTM.L - 1) * LAYER_SPACING * 0.5;
        sim.mirrorSphere.center.set(0, centerY, 0);
        sim.mirrorSphere.sphere.position.copy(sim.mirrorSphere.center);
      }
    }

    function updateEntropy(time, dt) {
      for (let l = 0; l < HTM.L; l++) {
        const layer = HTM.layers[l];
        layer.entropy += Math.sin(time * 0.35 + l * 0.85 + HTM.seed) * 0.012 * (1 + 0.2 * dt * 60);
        layer.entropy = Math.max(0, Math.min(4.0, layer.entropy));
      }
      const c = HTM.currentLayer;
      if (c < HTM.L - 1) {
        HTM.recognitionDelta = HTM.layers[c + 1].entropy - HTM.layers[c].entropy;
      } else {
        HTM.recognitionDelta = 0;
      }
    }

    function updateLayers(time) {
      HTM.layers.forEach((layer, l) => {
        const H = layer.entropy;
        const norm = Math.min(1, H / 4.0);
        const hue = 0.6 - norm * 0.6;
        const light = 0.3 + 0.18 * norm;
        layer.plane.material.color.setHSL(hue, 1, light);

        const pos = layer.flow.geometry.attributes.position;
        for (let i = 0; i < pos.count; i++) {
          let x = pos.getX(i);
          let z = pos.getZ(i);
          const w = 0.012 + 0.008 * l;
          const cR = Math.cos(w);
          const sR = Math.sin(w);
          const nx = x * cR - z * sR + Math.cos(time * 0.45 + l + HTM.seed) * 0.14;
          const nz = x * sR + z * cR + Math.sin(time * 0.45 + l * 1.2 + HTM.seed) * 0.14;
          x = Math.max(-GRID_SIZE / 2, Math.min(GRID_SIZE / 2, nx));
          z = Math.max(-GRID_SIZE / 2, Math.min(GRID_SIZE / 2, nz));
          pos.setX(i, x);
          pos.setZ(i, z);
        }
        pos.needsUpdate = true;

        const cPos = layer.cloud.geometry.attributes.position;
        const cavBoost = HTM.cavityEnabled ? 1.0 + 0.7 * Math.tanh(H) : 1.0;
        const scale = 1.0 + 0.05 * Math.sin(time * 1.2 + l * 0.8) * cavBoost;
        for (let i = 0; i < cPos.count; i++) {
          const x0 = cPos.getX(i);
          const y0 = cPos.getY(i);
          const z0 = cPos.getZ(i);
          cPos.setXYZ(i, x0 * scale, y0 * scale, z0 * scale);
        }
        cPos.needsUpdate = true;
        layer.cloud.material.opacity = 0.18 + 0.14 * norm * (HTM.cavityEnabled ? 1.2 : 1.0);
      });
    }

    // ========= UI SYNC & REGIME LABEL =========
    function updateRegimeLabel() {
      const mu = HTM.eigen.mu;
      const epsS = HTM.eigen.epsStable;
      const epsU = HTM.eigen.epsUnstable;

      const lamS_abs = 1.0; // e^{iθ} unit magnitude
      const lamU_abs = mu;

      const label = document.getElementById("regime-label");
      const lamLabel = document.getElementById("lambda-label");

      let regime = "recognition";
      let cls = "bg-emerald-900/60 text-emerald-300 mono";

      if (lamU_abs > 1.3 || epsU > 0.07) {
        regime = "hallucination";
        cls = "bg-fuchsia-900/60 text-fuchsia-300 mono";
      } else if (lamU_abs < 1.1 && epsU < 0.04 && epsS < 0.04) {
        regime = "drift / sleep";
        cls = "bg-indigo-900/60 text-indigo-300 mono";
      } else if (Math.abs(HTM.recognitionDelta) < 0.1) {
        regime = "critical / edge";
        cls = "bg-amber-900/60 text-amber-300 mono";
      }

      label.textContent = "regime: " + regime;
      label.className = "badge " + cls;
      lamLabel.textContent = `|λᵤ|=${lamU_abs.toFixed(2)} · |λₛ|≈${lamS_abs.toFixed(2)}`;
    }

    function syncUI() {
      const curr = HTM.currentLayer;
      const layer = HTM.layers[curr];
      document.getElementById("current-layer").textContent = curr + 1;
      document.getElementById("total-layers").textContent = HTM.L;
      document.getElementById("current-entropy").textContent = layer.entropy.toFixed(3);
      document.getElementById("recognition-delta").textContent = HTM.recognitionDelta.toFixed(3);
      const ev = document.getElementById("event-state");
      ev.textContent = HTM.eventActive ? "collapse" : "idle";
      ev.className = "mono " + (HTM.eventActive ? "text-red-400" : "text-slate-300");

      document.getElementById("param-mu").value = HTM.eigen.mu.toFixed(2);
      document.getElementById("param-eps-stable").value = HTM.eigen.epsStable.toFixed(3);
      document.getElementById("param-eps-unstable").value = HTM.eigen.epsUnstable.toFixed(3);
      document.getElementById("param-layers").value = HTM.L;
      document.getElementById("param-cavity-amp").value = HTM.cavityAmp.toFixed(3);

      const tSlider = document.getElementById("time-slider");
      if (timeMode === "scrub") {
        // manual scrub handled in event listener
      } else {
        tSlider.value = (HTM.t % (2 * Math.PI)) / (2 * Math.PI);
      }

      updateRegimeLabel();
    }

    function updateCavityButton() {
      const btn = document.getElementById("toggle-cavity");
      if (!btn) return;
      if (HTM.cavityEnabled) {
        btn.textContent = "Cavity: on";
        btn.className =
          "w-full bg-emerald-800/90 hover:bg-emerald-700 text-emerald-50 font-semibold py-1.5 px-3 rounded-md text-[0.7rem] transition duration-150";
      } else {
        btn.textContent = "Cavity: off";
        btn.className =
          "w-full bg-slate-800/95 hover:bg-slate-700 text-slate-100 font-semibold py-1.5 px-3 rounded-md text-[0.7rem] transition duration-150";
      }
    }

    // ========= PRESETS =========
    function applyPresetRecognition() {
      HTM.eigen.mu = 1.05;
      HTM.eigen.epsStable = 0.04;
      HTM.eigen.epsUnstable = 0.018;
      HTM.eventActive = false;
      HTM.cavityAmp = 0.018;
      HTM.cavityEnabled = true;
      HTM.seed = 1.234;
      HTM.layers.forEach((layer, l) => {
        const base = 1.0 + 0.1 * l;
        layer.entropy = base + 0.05 * Math.sin(l * 0.7);
      });
      consoleLog("preset: recognition");
    }

    function applyPresetChaos() {
      HTM.eigen.mu = 1.55;
      HTM.eigen.epsStable = 0.06;
      HTM.eigen.epsUnstable = 0.095;
      HTM.eventActive = true;
      HTM.cavityAmp = 0.05;
      HTM.cavityEnabled = true;
      HTM.seed = 4.2;
      HTM.layers.forEach((layer, l) => {
        const base = 2.0 + 0.8 * Math.sin(l * 1.2);
        layer.entropy = Math.min(4.0, base + 0.4 * Math.random());
      });
      consoleLog("preset: chaos/hallucination");
    }

    function applyPresetDrift() {
      HTM.eigen.mu = 1.12;
      HTM.eigen.epsStable = 0.03;
      HTM.eigen.epsUnstable = 0.028;
      HTM.eventActive = false;
      HTM.cavityAmp = 0.012;
      HTM.cavityEnabled = true;
      HTM.seed = 2.71;
      HTM.layers.forEach((layer, l) => {
        const base = 1.4 + 0.25 * Math.sin(l * 0.4);
        layer.entropy = base + 0.1 * Math.random();
      });
      consoleLog("preset: noisy drift");
    }

    function applyPresetCavity() {
      HTM.eigen.mu = 1.28;
      HTM.eigen.epsStable = 0.045;
      HTM.eigen.epsUnstable = 0.062;
      HTM.eventActive = false;
      HTM.cavityAmp = 0.08;
      HTM.cavityEnabled = true;
      HTM.seed = 3.14159;
      HTM.layers.forEach((layer, l) => {
        const base = 1.5 + 0.35 * Math.sin(l * 0.9);
        layer.entropy = base + 0.15 * Math.sin(l * 1.7 + HTM.seed);
      });
      consoleLog("preset: photon cavity box");
    }

    function applyPresetSleep() {
      HTM.eigen.mu = 1.02;
      HTM.eigen.epsStable = 0.02;
      HTM.eigen.epsUnstable = 0.018;
      HTM.eventActive = false;
      HTM.cavityAmp = 0.01;
      HTM.cavityEnabled = true;
      HTM.seed = 0.5;
      HTM.layers.forEach((layer, l) => {
        const base = 0.9 + 0.15 * Math.cos(l * 0.6);
        layer.entropy = base + 0.05 * Math.sin(l * 0.4 + HTM.seed);
      });
      consoleLog("preset: sleep / off-duty");
    }

    function setPresetActive(id) {
      ["preset-recognition", "preset-chaos", "preset-drift", "preset-cavity", "preset-sleep"].forEach((btnId) => {
        const btn = document.getElementById(btnId);
        btn.classList.remove("chip-btn-active");
      });
      if (id) {
        const b = document.getElementById(id);
        if (b) b.classList.add("chip-btn-active");
      }
    }

    // ========= STATE I/O =========
    function exportState() {
      const state = {
        L: HTM.L,
        seed: HTM.seed,
        eventActive: HTM.eventActive,
        cavityEnabled: HTM.cavityEnabled,
        cavityAmp: HTM.cavityAmp,
        eigen: {
          mu: HTM.eigen.mu,
          epsStable: HTM.eigen.epsStable,
          epsUnstable: HTM.eigen.epsUnstable
        },
        entropy: HTM.layers.map((l) => l.entropy)
      };
      const blob = new Blob([JSON.stringify(state, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "htm_cavity_state_ordis_v5.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      consoleLog("state exported to htm_cavity_state_ordis_v5.json");
    }

    function importState() {
      const text = prompt("Paste HTM state JSON here:");
      if (!text) return;
      try {
        const state = JSON.parse(text);
        if (!state || typeof state !== "object") throw new Error("bad json");
        if (typeof state.L === "number" && state.L >= 4 && state.L <= 64) {
          HTM.L = Math.floor(state.L);
        }
        if (typeof state.seed === "number") HTM.seed = state.seed;
        if (typeof state.eventActive === "boolean") HTM.eventActive = state.eventActive;
        if (typeof state.cavityEnabled === "boolean") HTM.cavityEnabled = state.cavityEnabled;
        if (typeof state.cavityAmp === "number") HTM.cavityAmp = state.cavityAmp;
        if (state.eigen) {
          if (typeof state.eigen.mu === "number") HTM.eigen.mu = state.eigen.mu;
          if (typeof state.eigen.epsStable === "number") HTM.eigen.epsStable = state.eigen.epsStable;
          if (typeof state.eigen.epsUnstable === "number") HTM.eigen.epsUnstable = state.eigen.epsUnstable;
        }
        setupLayers();
        if (Array.isArray(state.entropy)) {
          for (let l = 0; l < HTM.L && l < state.entropy.length; l++) {
            HTM.layers[l].entropy = Number(state.entropy[l]) || HTM.layers[l].entropy;
          }
        }
        consoleLog("state imported");
      } catch (err) {
        alert("Invalid JSON state.");
        consoleLog("failed to import state (invalid JSON)", "err");
      }
    }

    function randomizeSeeds() {
      HTM.seed = Math.random() * 10.0;
      HTM.layers.forEach((layer) => {
        layer.entropy = Math.random() * 2.5;
      });
    }

    function snapshotPNG() {
      try {
        const dataURL = renderer.domElement.toDataURL("image/png");
        const a = document.createElement("a");
        a.href = dataURL;
        a.download = "htm_cavity_screenshot_ordis_v5.png";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        consoleLog("snapshot saved as htm_cavity_screenshot_ordis_v5.png");
      } catch (e) {
        consoleLog("snapshot failed: " + e.message, "err");
      }
    }

    // ========= INIT & LOOP =========
    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(110, 130, 150);

      renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.rotateSpeed = 0.65;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.6;
      controls.screenSpacePanning = true;

      clock = new THREE.Clock();

      setupGlobalFrame();
      setupEigenHelices();
      setupMobius();
      setupLinks();
      setupLayers();
      setupMirrorSphere(); // new cavity

      const slider = document.getElementById("layer-slider");
      slider.addEventListener("input", (e) => {
        HTM.currentLayer = parseInt(e.target.value || "0", 10);
      });

      const timeSlider = document.getElementById("time-slider");
      timeSlider.addEventListener("input", (e) => {
        if (timeMode === "scrub") {
          const phase = parseFloat(e.target.value || "0");
          HTM.t = phase * 2 * Math.PI;
        }
      });

      document.getElementById("time-mode-btn").addEventListener("click", () => {
        timeMode = timeMode === "live" ? "scrub" : "live";
        if (timeMode === "scrub") {
          consoleSetStatus("scrub", "bg-fuchsia-900/60 text-fuchsia-300");
          document.getElementById("time-mode-btn").textContent = "scrub";
        } else {
          consoleSetStatus("live", "bg-sky-900/60 text-sky-300");
          document.getElementById("time-mode-btn").textContent = "live";
        }
      });

      document.getElementById("trigger-event").addEventListener("click", () => {
        HTM.eventActive = !HTM.eventActive;
        consoleLog(`attractor collapse ${HTM.eventActive ? "enabled" : "disabled"}`);
      });

      document.getElementById("toggle-cavity").addEventListener("click", () => {
        HTM.cavityEnabled = !HTM.cavityEnabled;
        updateCavityButton();
        consoleLog(`cavity ${HTM.cavityEnabled ? "enabled" : "disabled"}`);
      });

      document.getElementById("preset-recognition").addEventListener("click", () => {
        applyPresetRecognition();
        setPresetActive("preset-recognition");
      });
      document.getElementById("preset-chaos").addEventListener("click", () => {
        applyPresetChaos();
        setPresetActive("preset-chaos");
      });
      document.getElementById("preset-drift").addEventListener("click", () => {
        applyPresetDrift();
        setPresetActive("preset-drift");
      });
      document.getElementById("preset-cavity").addEventListener("click", () => {
        applyPresetCavity();
        setPresetActive("preset-cavity");
      });
      document.getElementById("preset-sleep").addEventListener("click", () => {
        applyPresetSleep();
        setPresetActive("preset-sleep");
      });

      document.getElementById("btn-export").addEventListener("click", exportState);
      document.getElementById("btn-import").addEventListener("click", importState);
      document.getElementById("btn-randomize").addEventListener("click", () => {
        randomizeSeeds();
        setPresetActive("");
        consoleLog("randomized entropy and seed");
      });
      document.getElementById("btn-freeze").addEventListener("click", () => {
        paused = !paused;
        if (paused) {
          consoleSetStatus("paused", "bg-slate-900/60 text-slate-300");
          consoleLog("simulation paused");
        } else {
          consoleSetStatus("live", "bg-sky-900/60 text-sky-300");
          consoleLog("simulation resumed");
        }
      });
      document.getElementById("btn-snapshot").addEventListener("click", snapshotPNG);

      const hudBtn = document.getElementById("toggle-hud-btn");
      const hudPanel = document.getElementById("hud-panel");
      let hudHidden = false;
      hudBtn.addEventListener("click", () => {
        hudHidden = !hudHidden;
        hudPanel.style.display = hudHidden ? "none" : "block";
        hudBtn.textContent = hudHidden ? "Show HUD" : "Hide HUD";
      });

      const consoleBtn = document.getElementById("toggle-console-btn");
      const consolePanel = document.getElementById("console-panel");
      let consoleHidden = false;
      consoleBtn.addEventListener("click", () => {
        consoleHidden = !consoleHidden;
        consolePanel.style.display = consoleHidden ? "none" : "block";
        consoleBtn.textContent = consoleHidden ? "Show Console" : "Hide Console";
      });

      const consoleInput = document.getElementById("console-input");
      const consoleSend = document.getElementById("console-send");
      const consoleClear = document.getElementById("console-clear");
      consoleSend.addEventListener("click", () => {
        handleConsoleCommand(consoleInput.value);
        consoleInput.value = "";
      });
      consoleInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          handleConsoleCommand(consoleInput.value);
          consoleInput.value = "";
        }
      });
      consoleClear.addEventListener("click", () => {
        document.getElementById("console-log").innerHTML = "";
      });

      window.addEventListener("resize", onResize);

      applyPresetRecognition();
      setPresetActive("preset-recognition");
      updateCavityButton();
      consoleLog("HTM Cavity Lab v5 + Mirror Sphere ready — type 'help' in the console");
      initMoE();
      animate();
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    

// === Ordis MoE / GRU Micro-Experts (v3) ===============================
// This block replaces the earlier toy MoE with a slightly more honest
// recurrent micro–MoE. Each expert is a tiny GRU cell with its own
// hidden state and random readout heads. A softmax router chooses which
// experts update on each frame based on HTM + mirror–sphere state.
// The whole thing is *still* tiny and light enough for mobile, but the
// dynamics are now genuinely recurrent, gated, and weakly plastic.

// ---- small linear algebra helpers ----
function randVec(n) {
  const v = new Array(n);
  for (let i = 0; i < n; i++) v[i] = (Math.random() - 0.5) * 0.6;
  return v;
}
function randMat(rows, cols) {
  const M = new Array(rows);
  for (let i = 0; i < rows; i++) {
    const row = new Array(cols);
    for (let j = 0; j < cols; j++) row[j] = (Math.random() - 0.5) * 0.35;
    M[i] = row;
  }
  return M;
}
function zeros(n) {
  const v = new Array(n);
  for (let i = 0; i < n; i++) v[i] = 0.0;
  return v;
}
function dotVec(a, b) {
  let s = 0.0;
  const n = Math.min(a.length, b.length);
  for (let i = 0; i < n; i++) s += a[i] * b[i];
  return s;
}
function addVec(a, b) {
  const n = Math.min(a.length, b.length);
  const out = new Array(n);
  for (let i = 0; i < n; i++) out[i] = a[i] + b[i];
  return out;
}
function hadamard(a, b) {
  const n = Math.min(a.length, b.length);
  const out = new Array(n);
  for (let i = 0; i < n; i++) out[i] = a[i] * b[i];
  return out;
}
function subScalarFromVec(s, a) {
  const out = new Array(a.length);
  for (let i = 0; i < a.length; i++) out[i] = s - a[i];
  return out;
}
function mulMatVec(M, v) {
  const out = new Array(M.length);
  for (let i = 0; i < M.length; i++) {
    out[i] = dotVec(M[i], v);
  }
  return out;
}
function sigmoid(z) {
  return 1.0 / (1.0 + Math.exp(-z));
}
function softmax(arr) {
  let max = -Infinity;
  for (let i = 0; i < arr.length; i++) if (arr[i] > max) max = arr[i];
  const exps = new Array(arr.length);
  let sum = 0.0;
  for (let i = 0; i < arr.length; i++) {
    const e = Math.exp(arr[i] - max);
    exps[i] = e;
    sum += e;
  }
  const out = new Array(arr.length);
  if (sum <= 0) {
    const frac = 1.0 / arr.length;
    for (let i = 0; i < arr.length; i++) out[i] = frac;
    return out;
  }
  for (let i = 0; i < arr.length; i++) out[i] = exps[i] / sum;
  return out;
}

// ---- tiny GRU expert ----
function TinyGRUExpert(kind, name, inputDim, hiddenDim) {
  this.kind = kind;         // "affect" or "reasoning"
  this.name = name;
  this.inputDim = inputDim;
  this.hiddenDim = hiddenDim;
  this.h = zeros(hiddenDim);
  this.age = 0.0;

  this.Wz = randMat(hiddenDim, inputDim);
  this.Uz = randMat(hiddenDim, hiddenDim);
  this.bz = randVec(hiddenDim);

  this.Wr = randMat(hiddenDim, inputDim);
  this.Ur = randMat(hiddenDim, hiddenDim);
  this.br = randVec(hiddenDim);

  this.Wh = randMat(hiddenDim, inputDim);
  this.Uh = randMat(hiddenDim, hiddenDim);
  this.bh = randVec(hiddenDim);

  // light readout heads
  this.headValence = randVec(hiddenDim);
  this.headActivation = randVec(hiddenDim);
  this.headCoherence = randVec(hiddenDim);
}

TinyGRUExpert.prototype.step = function(x, dt) {
  // z = σ(Wz x + Uz h + bz)
  const Wz_x = mulMatVec(this.Wz, x);
  const Uz_h = mulMatVec(this.Uz, this.h);
  const Wr_x = mulMatVec(this.Wr, x);
  const Ur_h = mulMatVec(this.Ur, this.h);
  const Wh_x = mulMatVec(this.Wh, x);
  const Uh_h = mulMatVec(this.Uh, this.h);

  const z = new Array(this.hiddenDim);
  const r = new Array(this.hiddenDim);
  const hTilde = new Array(this.hiddenDim);
  const hNew = new Array(this.hiddenDim);

  for (let i = 0; i < this.hiddenDim; i++) {
    const z_i = sigmoid(Wz_x[i] + Uz_h[i] + this.bz[i]);
    const r_i = sigmoid(Wr_x[i] + Ur_h[i] + this.br[i]);
    const hHat_i = Math.tanh(Wh_x[i] + r_i * Uh_h[i] + this.bh[i]);
    const h_i = this.h[i];
    const hNew_i = (1 - z_i) * h_i + z_i * hHat_i;
    z[i] = z_i;
    r[i] = r_i;
    hTilde[i] = hHat_i;
    hNew[i] = hNew_i;
  }

  this.h = hNew;
  this.age += dt;

  // simple heads
  const valence = Math.tanh(dotVec(this.headValence, this.h));
  const activation = sigmoid(dotVec(this.headActivation, this.h));
  const coherence = sigmoid(dotVec(this.headCoherence, this.h));

  return { valence, activation, coherence };
};

// light Hebbian-ish update on Wh
TinyGRUExpert.prototype.hebbianUpdate = function(x, lr) {
  const L = lr || 0.0008;
  for (let i = 0; i < this.Wh.length; i++) {
    const h_i = this.h[i];
    if (Math.abs(h_i) < 1e-3) continue;
    const row = this.Wh[i];
    for (let j = 0; j < row.length; j++) {
      row[j] += L * h_i * x[j];
    }
  }
};

// ---- router ----
function MoERouter(numExperts, keyDim) {
  this.keyDim = keyDim;
  this.keys = [];
  for (let i = 0; i < numExperts; i++) {
    this.keys.push(randVec(keyDim));
  }
}
MoERouter.prototype.route = function(x) {
  const scores = new Array(this.keys.length);
  for (let i = 0; i < this.keys.length; i++) {
    scores[i] = dotVec(this.keys[i], x);
  }
  return softmax(scores);
};

// ---- global MoE state ----
const MoE = {
  experts: [],
  router: null,
  inputDim: 6,
  hiddenDim: 4,
  maxExperts: 16,
  baseExperts: 8,
  lastSpawnTime: 0,
  metrics: {
    affect: 0.0,
    reasoning: 0.0,
    interactions: 0.0,
    regime: "idle"
  }
};

// build input vector from HTM + mirror sphere state
function buildMoEInputVector(time, normInteraction) {
  let normLayer = 0.0;
  let entropy = 0.0;
  let deltaH = 0.0;

  try {
    const L = HTM.L || (HTM.layers ? HTM.layers.length : 1);
    const c = HTM.currentLayer || 0;
    normLayer = L > 1 ? c / (L - 1) : 0.0;
    if (HTM.layers && HTM.layers[c]) {
      entropy = HTM.layers[c].entropy || 0.0;
    }
    deltaH = HTM.recognitionDelta || 0.0;
  } catch (_) {
    // leave defaults
  }

  const cavity = HTM.cavityEnabled ? HTM.cavityAmp : 0.0;
  const eNorm = Math.tanh(entropy / 4.0);
  const dNorm = THREE.MathUtils.clamp(deltaH / 2.0, -1.0, 1.0);
  const iNorm = THREE.MathUtils.clamp(normInteraction, 0.0, 1.0);
  const phase = Math.sin(time * 0.35 + HTM.seed);

  return [normLayer, eNorm, dNorm, cavity, iNorm, phase];
}

function initMoE() {
  if (typeof window === "undefined") return;
  if (!window.HTM) window.HTM = {};
  if (!HTM.hud) HTM.hud = {};

  MoE.experts = [];
  const kinds = [
    { kind: "affect", name: "valence" },
    { kind: "affect", name: "arousal" },
    { kind: "reasoning", name: "coherence" },
    { kind: "reasoning", name: "stability" },
    { kind: "affect", name: "tone" },
    { kind: "reasoning", name: "clarity" },
    { kind: "affect", name: "salience" },
    { kind: "reasoning", name: "focus" }
  ];
  kinds.forEach((cfg) => {
    MoE.experts.push(
      new TinyGRUExpert(cfg.kind, cfg.name, MoE.inputDim, MoE.hiddenDim)
    );
  });
  MoE.router = new MoERouter(MoE.maxExperts, MoE.inputDim);

  // HUD wiring (non-invasive: appended to existing hud-root)
  try {
    const hudRoot = document.getElementById("hud-root");
    if (hudRoot) {
      const label = document.createElement("p");
      label.id = "moe-affect-label";
      label.className = "mono text-[10px] text-cyan-300 mt-1";
      label.textContent = "Affect: 0.00 · Reasoning: 0.00";
      hudRoot.appendChild(label);
      HTM.hud.affectLabel = label;

      const expertsLine = document.createElement("p");
      expertsLine.id = "moe-experts-label";
      expertsLine.className = "mono text-[10px] text-sky-200";
      expertsLine.textContent = "Experts: 0 · affect gate mass: 0.00 · reasoning gate mass: 0.00";
      hudRoot.appendChild(expertsLine);
      HTM.hud.expertsLabel = expertsLine;

      const regimeLine = document.createElement("p");
      regimeLine.id = "moe-regime-label";
      regimeLine.className = "mono text-[10px] text-indigo-200";
      regimeLine.textContent = "Ensemble regime: idle";
      hudRoot.appendChild(regimeLine);
      HTM.hud.regimeLabel = regimeLine;
    }
  } catch (e) {
    console.warn("MoE HUD init failed", e);
  }
}

// One MoE update step driven by approximate photon–crystal interaction density.
function updateMoE(time, dt) {
  if (!sim || !sim.mirrorSphere || !MoE.router || !MoE.experts.length) return;
  const ms = sim.mirrorSphere;
  const photons = ms.photonPositions ? ms.photonPositions.array : null;
  const crystals = ms.crystals || [];
  if (!photons || crystals.length === 0) return;

  let interactionCount = 0;
  let hitThisFrame = false;
  const stride = 15;

  for (let i = 0; i < ms.numPhotons; i += stride) {
    const px = photons[3 * i];
    const py = photons[3 * i + 1];
    const pz = photons[3 * i + 2];
    for (let k = 0; k < crystals.length; k++) {
      const c = crystals[k];
      const dx = px - c.position.x;
      const dy = py - c.position.y;
      const dz = pz - c.position.z;
      const r = c.scale.x * 2.2;
      if (dx * dx + dy * dy + dz * dz < r * r) {
        interactionCount++;
        hitThisFrame = true;
        break;
      }
    }
  }

  const maxInteractions = (ms.numPhotons / stride) * crystals.length + 1e-6;
  const normInteraction = THREE.MathUtils.clamp(
    interactionCount / maxInteractions,
    0.0,
    1.0
  );
  MoE.metrics.interactions = normInteraction;

  const x = buildMoEInputVector(time, normInteraction);
  const gates = MoE.router.route(x);

  let affectMix = 0.0;
  let reasoningMix = 0.0;
  let gateMassA = 0.0;
  let gateMassR = 0.0;
  let activeCount = 0;
  const maxAge = 120.0;

  const lrBase = hitThisFrame ? 0.0012 : 0.0;

  MoE.experts.forEach((exp, idx) => {
    const gate = gates[idx % gates.length];
    if (gate < 0.03) {
      exp.age += dt;
      return;
    }
    activeCount++;

    const heads = exp.step(x, dt);
    if (exp.kind === "affect") {
      affectMix += gate * heads.valence;
      gateMassA += gate;
    } else {
      reasoningMix += gate * heads.coherence;
      gateMassR += gate;
    }

    if (lrBase > 0) {
      exp.hebbianUpdate(x, lrBase * gate);
    }
  });

  if (gateMassA > 0) affectMix /= gateMassA;
  if (gateMassR > 0) reasoningMix /= gateMassR;

  // spawn & prune: experts that are active, coherent, and in high-interaction regimes
  const now = time;
  if (
    activeCount > 0 &&
    MoE.experts.length < MoE.maxExperts &&
    now - MoE.lastSpawnTime > 3.5 &&
    reasoningMix > 0.55 &&
    normInteraction > 0.4
  ) {
    const parent = MoE.experts[Math.floor(Math.random() * MoE.experts.length)];
    const child = new TinyGRUExpert(
      parent.kind,
      parent.name + "_child",
      MoE.inputDim,
      MoE.hiddenDim
    );
    // seed child near parent state
    for (let i = 0; i < child.h.length && i < parent.h.length; i++) {
      child.h[i] = parent.h[i] * 0.6;
    }
    MoE.experts.push(child);
    MoE.lastSpawnTime = now;
  }

  MoE.experts = MoE.experts.filter((exp) => {
    if (MoE.experts.length <= MoE.baseExperts) return true;
    const mag = Math.sqrt(dotVec(exp.h, exp.h));
    return !(exp.age > maxAge && mag < 0.08);
  });

  MoE.metrics.affect = affectMix;
  MoE.metrics.reasoning = reasoningMix;

  let regime = "idle";
  if (affectMix > 0.6 && reasoningMix > 0.6) regime = "focused";
  else if (affectMix < -0.3 && reasoningMix < 0.4) regime = "suppressed";
  else if (normInteraction > 0.6) regime = "rich-interaction";
  MoE.metrics.regime = regime;

  if (window.HTM && HTM.hud && HTM.hud.affectLabel) {
    HTM.hud.affectLabel.textContent =
      "Affect: " +
      affectMix.toFixed(2) +
      " · Reasoning: " +
      reasoningMix.toFixed(2);

    if (HTM.hud.expertsLabel) {
      HTM.hud.expertsLabel.textContent =
        "Experts: " +
        MoE.experts.length +
        " · affect gate mass: " +
        gateMassA.toFixed(2) +
        " · reasoning gate mass: " +
        gateMassR.toFixed(2) +
        " · interactions: " +
        normInteraction.toFixed(2);
    }

    if (HTM.hud.regimeLabel) {
      HTM.hud.regimeLabel.textContent = "Ensemble regime: " + regime;
    }
  }
}


function animate() {
      requestAnimationFrame(animate);
      const elapsed = (clock && clock.getElapsedTime()) || 0;
      const dt = elapsed - lastFrameTime;
      lastFrameTime = elapsed;

      if (!paused) {
        if (timeMode === "live") {
          HTM.t += dt * 1.0;
        }
      }

      const time = HTM.t;

      updateEntropy(time, dt);
      updateGlobalFrame(time);
      updateEigenHelices(time, dt);
      updateMobius(time);
      updateLinks(time);
      updateLayers(time);
      updateMirrorSphere(time, dt);
      updateMoE(time, dt);
      syncUI();

      controls.update();
      renderer.render(scene, camera);
    }

    init();
  </script>
</body>
</html>
